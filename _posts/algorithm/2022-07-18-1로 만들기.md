---
toc: true
layout: post
comments: true
title: 1로 만들기
description: 1로 만들기 (백준 1463 - DP)
categories: [algorithm]
image:
---

# 1로 만들기 (백준 1463)

**백준 1463**

[1463번: 1로 만들기](https://www.acmicpc.net/problem/1463)

## **문제 설명**

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

## 예제 입력 1

```
2
```

## 예제 출력 1

```
1
```

## 예제 입력 2

```
10
```

## 예제 출력 2

```
3
```

## 힌트

10의 경우에 10 -> 9 -> 3 -> 1 로 3번 만에 만들 수 있다

---

## 문제풀이

`바텀 업(Bottom up)` 방식으로 문제를 풀어볼 수 있다. 

작은 문제들을 조합해서 풀어본다.

$a_{i} = i$ 를 1로 만들기 위한 최소 연산 횟수

$`a_{i} = min(a_{i-1},a_{i/2}, a_{i/3}) +1`$

3가지 경우의 수 중 **최소의 연산 횟수인 경우**를 가져와 1을 더해 현재 인덱스(index)에 기록

→ 1을 더하는 이유는 가져오는 것 자체가 연산 횟수 + 1이기 때문이다.

1부터 바텀업 방식으로 하게 되면 `n까지의 모든 최적의 경우의 수(최소 연산 횟수)`가 기록된다.

memoization을 입력 조건인 106까지 받을 수 있도록 

`d = [0] * 107` 로 할 경우

백준에서는 `Index Error`가 난다.

```python
n = int(input())

# index를 1로 만들기 위해 필요한 최소 연산 횟수가 기록된 리스트 = memoization
d = [0] * (n+1)

# 2부터 리스트를 채운다
for i in range(2, n+1):

	# 먼저 현재의 수에서 1을 뺀 경우의 수를 리스트 i 인덱스에 기록
	d[i] = d[i-1] + 1
	
	# 2로 나누어져 떨어진 경우와 비교
	if i%2 == 0 :
		d[i] = min(d[i], d[i//2]+1)

	# 3으로 나누어 떨어진 경우와 비교
	if i%3 == 0 :
		d[i] = min(d[i], d[i//3]+1)

print(d[n])

```